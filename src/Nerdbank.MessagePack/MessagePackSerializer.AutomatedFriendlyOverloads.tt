<#@ template debug="true" hostspecific="false" language="C#" #>
// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#pragma warning disable SA1402 // File may only contain a single type
#pragma warning disable SA1601 // Partial elements should be documented
#pragma warning disable RS0026 // optional parameter on a method with overloads

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO.Pipelines;
using Microsoft;

namespace Nerdbank.MessagePack;

#if NET

public partial record MessagePackSerializer
{<# WriteClass(targetNET: true); #>
}

#endif

public static partial class MessagePackSerializerExtensions
{<# WriteClass(targetNET: false); #>
}
<#
void WriteClass(bool targetNET) {
    static void AssembleInputs(string firstParameterType, string firstParameterName, bool moreParameters, out string firstParameter, out string firstArg, out string firstParameterDocId)
    {
        firstParameter = firstParameterType.Length == 0 ? "" : $"{firstParameterType} {firstParameterName}";
        firstArg = firstParameterName.Length == 0 ? "" : $"{firstParameterName}";
        firstParameterDocId = firstParameterType.Length == 0 ? "" : $"{firstParameterType.Replace("scoped ", "").Replace('<', '{').Replace('>', '}')}, ";

        if (moreParameters)
        {
            if (firstParameter.Length > 0) firstParameter += ", ";
            if (firstArg.Length > 0) firstArg += ", ";
        }
    }

    foreach (ShapeSource shapeSource in Enum.GetValues(typeof(ShapeSource)))
    {
        (string genericTypeParameters, string genericTypeParametersWithElement, string typeConstraint, string getShape) = shapeSource switch
        {
            ShapeSource.T => ("T","T, TElement", targetNET ? "T : IShapeable<T>" : null, targetNET ? "T.GetTypeShape()" : "TypeShapeResolver.ResolveDynamicOrThrow<T>()"),
            ShapeSource.TProvider => ("T, TProvider","T, TElement, TProvider", targetNET ? "TProvider : IShapeable<T>" : null, targetNET ? "TProvider.GetTypeShape()" : "TypeShapeResolver.ResolveDynamicOrThrow<T, TProvider>()"),
            _ => throw new NotSupportedException(),
        };
        typeConstraint = typeConstraint is null ? "" : $"where {typeConstraint} ";

        string serializerClassQualifier = targetNET ? "" : "MessagePackSerializer.";
        string thisParameter = targetNET ? "" : "this MessagePackSerializer self, ";
        string thisKeyword = targetNET ? "this" : "Requires.NotNull(self)";
        string staticModifier = targetNET ? "" : "static ";
        string methodAttributes = targetNET ? "" : """
        
            #if NET8_0
            	[RequiresDynamicCode(ResolveDynamicMessage)]
            #endif
            #if NET
            	[PreferDotNetAlternativeApi(MessagePackSerializer.PreferTypeConstrainedInstanceOverloads)]
            	[EditorBrowsable(EditorBrowsableState.Never)]
            #endif
            """;
        string sourceGenRequiredDocs = targetNET ? "" : shapeSource switch
        {
            ShapeSource.T => $$"""

            	/// <exception cref="NotSupportedException">Thrown if <typeparamref name="T"/> has no type shape created via the <see cref="GenerateShapeAttribute"/> source generator.</exception>
            	/// <remarks>
            	/// This overload should only be used when <typeparamref name="T"/> is decorated with the <see cref="GenerateShapeAttribute"/>.
            	/// For non-decorated types, apply <see cref="GenerateShapeForAttribute{T}"/> to a witness type and call <see cref="GetJsonSchema{T, TProvider}"/> instead,
            	/// or use an overload that accepts a <see cref="ITypeShapeProvider"/> for an option that does not require source generation.
            	/// </remarks>
            """,
            ShapeSource.TProvider => $$"""

            	/// <exception cref="NotSupportedException">Thrown if <typeparamref name="TProvider"/> has no <see cref="GenerateShapeForAttribute{T}"/> source generator attribute for <typeparamref name="T"/>.</exception>
            	/// <remarks>
            	/// This overload should only be used when <typeparamref name="TProvider"/> is decorated with a <see cref="GenerateShapeForAttribute{T}"/>.
            	/// Use an overload that accepts a <see cref="ITypeShapeProvider"/> for an option that does not require source generation.
            	/// </remarks>
            """,
            _ => throw new NotSupportedException(),
        };

        foreach (SerializeTransport transport in Enum.GetValues(typeof(SerializeTransport)))
        {
            (string returnType, string firstParameterType, string firstParameterName) = transport switch
            {
                SerializeTransport.ByteArray => ("byte[]", "", ""),
                SerializeTransport.IBufferWriter => ("void", "IBufferWriter<byte>", "writer"),
                SerializeTransport.Stream => ("void", "Stream", "stream"),
                _ => throw new NotSupportedException(),
            };
            AssembleInputs(firstParameterType, firstParameterName, true, out string firstParameter, out string firstArg, out string firstParameterDocId);
#>

	/// <inheritdoc cref="<#=serializerClassQualifier#>Serialize{T}(<#=firstParameterDocId#>in T, ITypeShape{T}, CancellationToken)" /><#= sourceGenRequiredDocs #>
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #><#= returnType #> Serialize<<#=genericTypeParameters#>>(<#=thisParameter#><#=firstParameter#>in T? value, CancellationToken cancellationToken = default)
		<#=typeConstraint#>=> <#= thisKeyword #>.Serialize(<#=firstArg#>value, <#=getShape#>, cancellationToken);
<#
        }

        foreach (DeserializeTransport transport in Enum.GetValues(typeof(DeserializeTransport)))
        {
            (string firstParameterType, string firstParameterName) = transport switch
            {
                DeserializeTransport.ReadOnlyMemory => ("ReadOnlyMemory<byte>", "bytes"),
                DeserializeTransport.ReadOnlySequence => ("scoped in ReadOnlySequence<byte>", "bytes"),
                DeserializeTransport.Stream => ("Stream", "stream"),
                _ => throw new NotSupportedException(),
            };
            AssembleInputs(firstParameterType, firstParameterName, false, out string firstParameter, out string firstArg, out string firstParameterDocId);
#>

	/// <inheritdoc cref="<#=serializerClassQualifier#>Deserialize{T}(<#=firstParameterDocId#>ITypeShape{T}, CancellationToken)" /><#= sourceGenRequiredDocs #>
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #>T? Deserialize<<#=genericTypeParameters#>>(<#=thisParameter#><#=firstParameter#>, CancellationToken cancellationToken = default)
		<#=typeConstraint#>=> <#= thisKeyword #>.Deserialize(<#=firstArg#>, <#=getShape#>, cancellationToken);
<#
        }

        foreach (DeserializeAsyncTransport transport in Enum.GetValues(typeof(DeserializeAsyncTransport)))
        {
            (string firstParameterType, string firstParameterName) = transport switch
            {
                DeserializeAsyncTransport.PipeReader => ("PipeReader", "reader"),
                DeserializeAsyncTransport.Stream => ("Stream", "stream"),
                _ => throw new NotSupportedException(),
            };
            AssembleInputs(firstParameterType, firstParameterName, false, out string firstParameter, out string firstArg, out string firstParameterDocId);
#>

	/// <inheritdoc cref="<#=serializerClassQualifier#>DeserializeAsync{T}(<#=firstParameterDocId#>ITypeShape{T}, CancellationToken)" /><#= sourceGenRequiredDocs #>
#pragma warning disable RS0027 // optional parameter on a method with overloads
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #>ValueTask<T?> DeserializeAsync<<#=genericTypeParameters#>>(<#=thisParameter#><#=firstParameter#>, CancellationToken cancellationToken = default)
#pragma warning restore RS0027 // optional parameter on a method with overloads
		<#=typeConstraint#>=> <#= thisKeyword #>.DeserializeAsync(<#=firstArg#>, <#=getShape#>, cancellationToken);

	/// <inheritdoc cref="<#=serializerClassQualifier#>DeserializeEnumerableAsync{T}(<#=firstParameterDocId#>ITypeShape{T}, CancellationToken)" /><#= sourceGenRequiredDocs #>
#pragma warning disable RS0027 // optional parameter on a method with overloads
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #>IAsyncEnumerable<T?> DeserializeEnumerableAsync<<#=genericTypeParameters#>>(<#=thisParameter#><#=firstParameter#>, CancellationToken cancellationToken = default)
#pragma warning restore RS0027 // optional parameter on a method with overloads
		<#=typeConstraint#>=> <#= thisKeyword #>.DeserializeEnumerableAsync(<#=firstArg#>, <#=getShape#>, cancellationToken);

	/// <inheritdoc cref="<#=serializerClassQualifier#>DeserializeEnumerableAsync{T, TElement}(<#=firstParameterDocId#>ITypeShape{T}, <#=serializerClassQualifier#>StreamingEnumerationOptions{T, TElement}, CancellationToken)" /><#= sourceGenRequiredDocs #>
#pragma warning disable RS0027 // optional parameter on a method with overloads
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #>IAsyncEnumerable<TElement?> DeserializeEnumerableAsync<<#=genericTypeParametersWithElement#>>(<#=thisParameter#><#=firstParameter#>, <#=serializerClassQualifier#>StreamingEnumerationOptions<T, TElement> options, CancellationToken cancellationToken = default)
#pragma warning restore RS0027 // optional parameter on a method with overloads
		<#=typeConstraint#>=> <#= thisKeyword #>.DeserializeEnumerableAsync(<#=firstArg#>, <#=getShape#>, options, cancellationToken);
<#
        }

        foreach (SerializeAsyncTransport transport in Enum.GetValues(typeof(SerializeAsyncTransport)))
        {
            (string firstParameterType, string firstParameterName) = transport switch
            {
                SerializeAsyncTransport.PipeWriter => ("PipeWriter", "writer"),
                SerializeAsyncTransport.Stream => ("Stream", "stream"),
                _ => throw new NotSupportedException(),
            };
            AssembleInputs(firstParameterType, firstParameterName, false, out string firstParameter, out string firstArg, out string firstParameterDocId);
#>

	/// <inheritdoc cref="<#=serializerClassQualifier#>SerializeAsync{T}(<#=firstParameterDocId#>T, ITypeShape{T}, CancellationToken)" /><#= sourceGenRequiredDocs #>
#pragma warning disable RS0027 // optional parameter on a method with overloads
	[ExcludeFromCodeCoverage]<#= methodAttributes #>
	public <#= staticModifier #>ValueTask SerializeAsync<<#=genericTypeParameters#>>(<#=thisParameter#><#=firstParameter#>, in T? value, CancellationToken cancellationToken = default)
#pragma warning restore RS0027 // optional parameter on a method with overloads
		<#=typeConstraint#>=> <#= thisKeyword #>.SerializeAsync(<#=firstArg#>, value, <#=getShape#>, cancellationToken);
<#
        }
    }
}
#>
<#+
  enum SerializeTransport
  {
      // MessagePackWriter, // this is hand-authored with intentionally limited overloads
      ByteArray,
      IBufferWriter,
      Stream,
  }
  enum DeserializeTransport
  {
      // MessagePackReader, // this is hand-authored with intentionally limited overloads
      ReadOnlyMemory,
      ReadOnlySequence,
      Stream,
  }
  enum SerializeAsyncTransport
  {
      PipeWriter,
      Stream,
  }
  enum DeserializeAsyncTransport
  {
      PipeReader,
      Stream,
  }
  enum ShapeSource
  {
      // Parameter, // This is hand-authored, and is what the automatically generated overloads forward to.
      T,
      TProvider,
  }
#>
