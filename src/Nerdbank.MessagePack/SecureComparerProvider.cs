// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Nerdbank.MessagePack;

/// <summary>
/// An implementation of <see cref="IComparerProvider"/> that provides
/// hash-collision resistant implementations of <see cref="IEqualityComparer{T}"/>
/// generated by <see cref="StructuralEqualityComparer.GetHashCollisionResistant{T}(ITypeShape{T})"/>.
/// </summary>
/// <seealso href="../docs/security.html#hash-collisions">Security: hash collisions</seealso>
public class SecureComparerProvider : IComparerProvider
{
	/// <summary>
	/// A singleton instance of the <see cref="SecureComparerProvider"/>.
	/// </summary>
	public static readonly SecureComparerProvider Default = new();

	private SecureComparerProvider()
	{
	}

	/// <inheritdoc/>
	/// <remarks>
	/// <para>
	/// This implementation always returns <see langword="null" />, since the security implications on comparers
	/// is (currently) limited to hash-based attacks, and <see cref="IComparer{T}"/> objects do not use hashing.
	/// </para>
	/// <para>
	/// Derived types may override this method to return comparers where desired.
	/// </para>
	/// </remarks>
	public virtual IComparer<T>? GetComparer<T>(ITypeShape<T> shape) => null;

	/// <inheritdoc/>
	/// <remarks>
	/// <para>
	/// This implementation returns the result of calling <see cref="StructuralEqualityComparer.GetHashCollisionResistant{T}(ITypeShape{T})"/>
	/// with the given <paramref name="shape"/>.
	/// </para>
	/// <para>
	/// Derived types may override this method and return custom implementations of <see cref="IEqualityComparer{T}"/>
	/// for types for which the <see cref="StructuralEqualityComparer"/>-generated comparer is not sufficient,
	/// deferring to the base implementation for the rest.
	/// </para>
	/// </remarks>
	public virtual IEqualityComparer<T>? GetEqualityComparer<T>(ITypeShape<T> shape) => StructuralEqualityComparer.GetHashCollisionResistant(shape);
}
