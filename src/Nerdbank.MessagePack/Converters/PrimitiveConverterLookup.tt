<#@ assembly name="System.Core" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Linq" #>
// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

#pragma warning disable SA1306 // Field names should begin with lower-case letter
#pragma warning disable SA1309 // Field names should not begin with underscore

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Nerdbank.MessagePack.Converters;

<#
var convertersByType = new List<ConverterInfo>
{
	new ConverterInfo("char", "CharConverter"),
	new ConverterInfo("byte", "ByteConverter"),
	new ConverterInfo("sbyte", "SByteConverter"),
	new ConverterInfo("short", "Int16Converter"),
	new ConverterInfo("ushort", "UInt16Converter"),
	new ConverterInfo("int", "Int32Converter"),
	new ConverterInfo("uint", "UInt32Converter"),
	new ConverterInfo("long", "Int64Converter"),
	new ConverterInfo("ulong", "UInt64Converter"),
	new ConverterInfo("System.Numerics.BigInteger", "BigIntegerConverter") { LazyLoad = true },
	new ConverterInfo("bool", "BooleanConverter"),
	new ConverterInfo("float", "SingleConverter"),
	new ConverterInfo("double", "DoubleConverter"),
	new ConverterInfo("decimal", "DecimalConverter"),
	new ConverterInfo("DateTime", "DateTimeConverter"),
	new ConverterInfo("DateTimeOffset", "DateTimeOffsetConverter"),
	new ConverterInfo("TimeSpan", "TimeSpanConverter"),
	new ConverterInfo("System.Text.Rune", "RuneConverter", "NET"),
	new ConverterInfo("Int128", "Int128Converter", "NET"),
	new ConverterInfo("UInt128", "UInt128Converter", "NET"),
	new ConverterInfo("Half", "HalfConverter", "NET"),
	new ConverterInfo("TimeOnly", "TimeOnlyConverter", "NET"),
	new ConverterInfo("DateOnly", "DateOnlyConverter", "NET"),
	new ConverterInfo("System.Globalization.CultureInfo", "SystemGlobalizationCultureInfoConverter"),
	new ConverterInfo("System.Text.Encoding", "SystemTextEncodingConverter"),
	new ConverterInfo("System.Drawing.Color", "SystemDrawingColorConverter") { LazyLoad = true },
	new ConverterInfo("System.Drawing.Point", "SystemDrawingPointConverter") { LazyLoad = true },
	new ConverterInfo("Memory<byte>", "MemoryOfByteConverter"),
	new ConverterInfo("ReadOnlyMemory<byte>", "ReadOnlyMemoryOfByteConverter"),
	new ConverterInfo("Guid", "GuidAsBinaryConverter"),
	new ConverterInfo("string", "StringConverter", IsRefType: true),
	new ConverterInfo("Version", "VersionConverter", IsRefType: true),
	new ConverterInfo("Uri", "UriConverter", IsRefType: true),
	new ConverterInfo("byte[]", "ByteArrayConverter", IsRefType: true),
	new ConverterInfo("Nerdbank.MessagePack.RawMessagePack", "RawMessagePackConverter"),
	new ConverterInfo("Nerdbank.MessagePack.MessagePackValue", "MessagePackValueConverter"),
	new ConverterInfo("Nerdbank.MessagePack.Extension", "ExtensionConverter"),
};
#>
/// <summary>
/// Provides access to built-in converters for primitive types.
/// </summary>
/// <remarks>
/// <para>This class is carefully crafted to avoid assembly loads by testing type names
/// rather than types directly for types declared in assemblies that may not be loaded.</para>
/// <para>On .NET, this class is also carefully crafted to help trimming be effective by avoiding type references
/// to types that are not used in the application.
/// Although the retrieval method references all the types, the fact that it is generic gives the
/// JIT/AOT compiler the opportunity to only reference types that match the type argument
/// (at least for the value types).
/// The generic method itself leads to more methods to JIT at runtime when NativeAOT is *not* used.
/// It's a trade-off, which is why we never use the generic method on .NET Framework where NativeAOT isn't even an option.
/// </para>
/// </remarks>
internal static class PrimitiveConverterLookup
{
<# foreach (var converterGroup in convertersByType.GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) { #>
	private static IMessagePackConverterInternal? <#=converter.FieldName#>;
<#	  if (converter.IsRefType) { #>
	private static IMessagePackConverterInternal? <#=converter.ReferencePreservingFieldName#>;
<#	  }
	 }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>

#if NET
	/// <summary>
	/// Gets a built-in converter for the given type, if one is available.
	/// </summary>
	/// <typeparam name="T">The type to get a converter for.</typeparam>
	/// <param name="referencePreserving">Indicates whether a reference-preserving converter is requested.</param>
	/// <param name="converter">Receives the converter, if one is available.</param>
	/// <returns><see langword="true" /> if a converter was found; <see langword="false" /> otherwise.</returns>
	internal static bool TryGetPrimitiveConverter<T>(ReferencePreservationMode referencePreserving, [NotNullWhen(true)] out MessagePackConverter<T>? converter)
#else
	/// <summary>
	/// Gets a built-in converter for the given type, if one is available.
	/// </summary>
	/// <param name="type">The type to get a converter for.</param>
	/// <param name="referencePreserving">Indicates whether a reference-preserving converter is requested.</param>
	/// <param name="converter">Receives the converter, if one is available.</param>
	/// <returns><see langword="true" /> if a converter was found; <see langword="false" /> otherwise.</returns>
	internal static bool TryGetPrimitiveConverter(Type type, ReferencePreservationMode referencePreserving, [NotNullWhen(true)] out MessagePackConverter? converter)
#endif
	{
<# foreach (var converterGroup in convertersByType.Where(c => !c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
#if NET
		if (typeof(T) == typeof(<#=converter.TypeName#>)<#=featureCondition#>)
#else
		if (type == typeof(<#=converter.TypeName#>)<#=featureCondition#>)
#endif
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
#if NET
				converter = (MessagePackConverter<T>)(<#=converter.ReferencePreservingFieldName#> ??= new <#= converter.ConverterName #>().WrapWithReferencePreservation());
#else
				converter = (MessagePackConverter)(<#=converter.ReferencePreservingFieldName#> ??= new <#= converter.ConverterName #>().WrapWithReferencePreservation());
#endif
			}
			else
			{
#if NET
				converter = (MessagePackConverter<T>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #>());
#else
				converter = (MessagePackConverter)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #>());
#endif
			}

<# } else { #>
#if NET
			converter = (MessagePackConverter<T>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #>());
#else
			converter = (MessagePackConverter)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #>());
#endif
<# } #>
			return true;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>

#if NET
		string primitiveTypeName = typeof(T).Name;
#else
		string primitiveTypeName = type.Name;
#endif
		string? primitiveTypeNamespace = null;

<# foreach (var converterGroup in convertersByType.Where(c => c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		// Type.Name is cheap, but not free.
		// Type.Namespace is more expensive.
		// Type.FullName is the most expensive.
		// Therefore, we only obtain these properties when we must.
		string leafName = converter.TypeName.Substring(converter.TypeName.LastIndexOf('.') + 1);
		string ns = converter.TypeName.Substring(0, converter.TypeName.LastIndexOf('.'));
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
#if NET
		if (primitiveTypeName == "<#=leafName#>" && (primitiveTypeNamespace ??= typeof(T).Namespace) == "<#=ns#>"<#=featureCondition#>)
#else
		if (primitiveTypeName == "<#=leafName#>" && (primitiveTypeNamespace ??= type.Namespace) == "<#=ns#>"<#=featureCondition#>)
#endif
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
#if NET
				converter = (MessagePackConverter<T>?)(<#=converter.ReferencePreservingFieldName#> ??= Create<#=converter.ConverterName#><T>().WrapWithReferencePreservation());
#else
				converter = (MessagePackConverter?)(<#=converter.ReferencePreservingFieldName#> ??= Create<#=converter.ConverterName#><T>().WrapWithReferencePreservation());
#endif
			}
			else
			{
#if NET
				converter = (MessagePackConverter<T>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#else
				converter = (MessagePackConverter?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#endif
			}

<# } else { #>
#if NET
			converter = (MessagePackConverter<T>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#else
			converter = (MessagePackConverter?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#>(type));
#endif
<# } #>
			return converter is not null;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>
		converter = null;
		return false;
	}
<# foreach (var converter in convertersByType.Where(c => c.LazyLoad)) { 
    // The runtime type check serves both to ensure type identity beyond string comparison
    // and (perhaps more importantly) to preserve trimming of unused types, since the trimmer
    // does not trim based on string comparisons.
#>

	[MethodImpl(MethodImplOptions.NoInlining)]
#if NET
	private static IMessagePackConverterInternal? Create<#=converter.ConverterName#><T>() => typeof(T) == typeof(<#=converter.TypeName#>) ? new <#=converter.ConverterName#>() : null;
#else
	private static IMessagePackConverterInternal? Create<#=converter.ConverterName#>(Type type) => type == typeof(<#=converter.TypeName#>) ? new <#=converter.ConverterName#>() : null;
#endif
<# } #>
}
<#+
record struct ConverterInfo(string TypeName, string ConverterName, string PreprocessorCondition = null, bool IsRefType = false, string Feature = null)
{
	internal string FieldName => $"_{ConverterName}";
	internal string ReferencePreservingFieldName => $"{FieldName}ReferencePreserving";
	internal bool LazyLoad { get; set; }
}
#>
