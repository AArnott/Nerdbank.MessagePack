// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Nerdbank.MessagePack.Analyzers;

[Generator]
public class Generator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValueProvider<DataModel> dataModelProvider = context.CompilationProvider.Select((compilation, token) =>
		{
			if (!ReferenceSymbols.TryCreate(compilation, out ReferenceSymbols? refSymbols))
			{
				return DataModel.Empty;
			}

			List<(string DataTypeName, string ConverterName)> converters = new();
			foreach (INamedTypeSymbol type in compilation.GlobalNamespace.GetTypeMembers())
			{
				if (type.IsAbstract || type.IsStatic)
				{
					continue;
				}

				if (type.BaseType is { IsGenericType: true, TypeArguments: [ITypeSymbol dataType] } baseType &&
					SymbolEqualityComparer.Default.Equals(baseType.ConstructUnboundGenericType(), refSymbols.MessagePackConverterUnbound))
				{
				}
			}

			return new DataModel(converters.ToImmutableArray());
		});

		context.RegisterSourceOutput(dataModelProvider, this.GenerateSource);
	}

	private void GenerateSource(SourceProductionContext context, DataModel? model)
	{
		if (model is null or { Converters.IsEmpty: true })
		{
			return;
		}

		SourceWriter writer = new('\t', 1);
		writer.WriteLine("// <auto-generated/>");

		context.AddSource("AsociatedTypesForConverters.cs", writer.ToSourceText());
	}

	private record class DataModel(
		ImmutableArray<(string DataTypeName, string ConverterName)> Converters) : IEquatable<DataModel>
	{
		internal static DataModel Empty { get; } = new(ImmutableArray<(string, string)>.Empty);

		public virtual bool Equals(DataModel other) => this.Converters.SequenceEqual(other.Converters);

		public override int GetHashCode() => this.Converters.Length;
	}
}
